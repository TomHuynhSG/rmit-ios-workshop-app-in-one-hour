<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 9: Data Flow, MVVM & Observation Framework - COSC3062</title>
    <link rel="icon" href="../assets/images/rmit-logo.png" type="image/png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <link rel="stylesheet" href="../css/base-theme.css">
    <link rel="stylesheet" href="../css/extended-header.css">
    <link rel="stylesheet" href="../css/collapsible.css">
    <link rel="stylesheet" href="../css/code-styles.css">
    <link rel="stylesheet" href="../css/shared-styles.css">
    <style>
        .logo { height: 60px; }
        .university-name { font-size: 1.75rem; }
        header .intro { max-width: 700px; }
        .cheatsheet-section > h2.collapsible-header {
            font-size: 2rem;
            color: var(--heading-color);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
        }
        .grid-container {
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 20px;
        }
        .card { padding: 20px; }
        pre { margin-bottom: 10px; }
        .instruction-step.card { padding: 20px; }
        .card ul, .card ol {
            padding-left: 20px;
        }
        .card ul {
            list-style-type: disc;
        }
        .pro-tip {
            background-color: var(--accent-color-light);
            border-left: 5px solid var(--accent-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .pro-tip h4 {
            margin-top: 0;
            color: var(--accent-color);
        }
    </style>
</head>
<body>

    <header>
        <div class="container">
            <div class="back-to-home-container">
                <a href="../index.html" class="back-to-home-button">&larr; Back to Home</a>
            </div>
            <div class="university-branding">
                <img src="https://sites.rmit.edu.au/artschoolgraduates/files/2022/10/rmit-logo-red.png" alt="RMIT University Logo" class="logo">
                <span class="university-name">RMIT University</span>
            </div>
            <h1>Week 9: Data Flow, MVVM & Observation Framework <span>Lab Guide</span></h1>
            <p class="intro">This lab focuses on structuring modern SwiftUI applications. We'll master the <strong>Model-View-ViewModel (MVVM)</strong> architecture and explore the powerful tools SwiftUI provides for managing data flow, including the latest Observation framework.</p>
        </div>
    </header>

    <main class="container">
        <section class="cheatsheet-section" id="objective">
            <h2 class="collapsible-header start-open">
                üéØ Objective
                <span class="collapse-icon"></span>
            </h2>
            <div class="collapsible-content">
                <div class="card instruction-step">
                    <h3>Goal of This Lab</h3>
                    <p>Today's lab is designed to give you hands-on practice with the <strong>Model-View-ViewModel (MVVM)</strong> architecture. The goal is not just to follow steps, but to understand <em>why</em> MVVM is a powerful pattern for building robust, scalable, and maintainable SwiftUI applications.</p>
                    <p>Your task is to refactor several projects from a traditional, mixed-logic approach into a clean MVVM structure, correctly separating data (Model), UI (View), and business logic (ViewModel).</p>
                    <img src="../assets/guide_imgs/mvmm/goal-of-this-lab.png" alt="Diagram illustrating the goal of the lab" class="img-large">
                    <div class="pro-tip">
                        <h4>A Simple Analogy for MVVM</h4>
                        <p>Think of a restaurant. The <strong>Model</strong> is the raw ingredients in the kitchen (flour, tomatoes, cheese). The <strong>View</strong> is the menu the customer sees and the waiter who takes the order. The <strong>ViewModel</strong> is the chef who takes the order ("Margherita Pizza"), prepares the ingredients according to the recipe (the business logic), and hands the finished pizza to the waiter to be displayed. The waiter doesn't need to know how to cook, and the chef doesn't need to talk to the customer.</p>
                    </div>
                    <img src="../assets/guide_imgs/mvmm/mvvm-analogy.png" alt="A simple analogy for MVVM" class="img-large">
                    
                </div>
            </div>
        </section>

        <section class="cheatsheet-section" id="key-concepts">
            <h2 class="collapsible-header">
                üîë Key Concepts & Property Wrappers
                <span class="collapse-icon"></span>
            </h2>
            <div class="collapsible-content">
                <div class="card instruction-step">
                    <h3>Understanding SwiftUI's Data Flow Tools</h3>
                    <p>SwiftUI provides a powerful set of tools, primarily through property wrappers, to manage the state of your application. Understanding their roles is crucial for implementing MVVM correctly. Think of them as special labels that tell SwiftUI how to manage a piece of data.</p>
                    <ul>
                        <li><strong>View State:</strong> Manages data that is private and specific to a single view.
                            <ul>
                                <li><code>@State</code>: The most common property wrapper. Use it for simple data (like a <code>String</code> for a text field, an <code>Int</code> for a counter, or a <code>Bool</code> for a toggle) that a view owns and modifies. When a <code>@State</code> property changes, the view automatically re-renders its UI to reflect the change. <br><strong>When to use:</strong> For simple, local view state that isn't shared.</li>
                                <li><code>@Binding</code>: Creates a derived, two-way connection to another source of truth (often a parent's <code>@State</code> or a ViewModel's property). It allows a child view to read and write a value that it doesn't own, like passing a light switch to a child view so it can turn a lamp in the parent view on or off. <br><strong>When to use:</strong> In child views that need to modify data owned by a parent view.</li>
                            </ul>
                        </li>
                        <li><strong>Shared State / Model Data:</strong> Manages more complex, reference-type data (classes) that can be shared across multiple views. This is the core of MVVM's state management.
                            <ul>
                                <li><code>@StateObject</code>: Use this to <strong>create and own</strong> an instance of an <code>ObservableObject</code> (your ViewModel) within a view. SwiftUI ensures the object's lifecycle is tied to the view, meaning it persists even when the view struct is re-created. This is the correct choice when a view is the "source of truth" for a ViewModel. <br><strong>When to use:</strong> The first time you create a ViewModel in a view.</li>
                                <li><code>@ObservedObject</code>: Use this when a view needs to <strong>observe and react to</strong> an existing instance of an <code>ObservableObject</code> that it receives from a parent view. The view does not own the object's lifecycle. <br><strong>When to use:</strong> When a view is passed a ViewModel from a parent view.</li>
                                <li><code>@EnvironmentObject</code>: A powerful dependency injection tool. It allows you to inject a shared <code>ObservableObject</code> into the entire view hierarchy, making it accessible to any child view without needing to pass it down manually through every layer (a process known as "prop drilling"). <br><strong>When to use:</strong> For data that many different views deep in your hierarchy need to access, like user settings or authentication status.</li>
                            </ul>
                        </li>
                        <li><strong>Persistent State:</strong> Manages data that needs to persist across app launches.
                            <ul>
                                <li><code>@AppStorage</code>: A convenient wrapper for <code>UserDefaults</code>. Ideal for storing simple, non-sensitive user preferences like a dark mode setting or a high score. <br><strong>When to use:</strong> For simple user settings that should be remembered when the app closes.</li>
                            </ul>
                        </li>
                    </ul>
                    <img src="../assets/guide_imgs/mvmm/key-concepts-and-property-wrappers.png" alt="Diagram of SwiftUI property wrappers" class="img-large">
                </div>
            </div>
        </section>

        <section class="cheatsheet-section" id="task1">
            <h2 class="collapsible-header">
                üìù Task 1: Refactoring a Counter App from MVC to MVVM
                <span class="collapse-icon"></span>
            </h2>
            <div class="collapsible-content">
                <div class="card instruction-step">
                    <h3>Objective</h3>
                    <p>You will start with a basic SwiftUI application implemented using the MVC (Model-View-Controller) design pattern. Your task is to refactor it using the MVVM (Model-View-ViewModel) architecture. This will provide a foundational understanding of how MVVM organizes and separates concerns.</p>
                    
                    <h4>1. Starter Project (The "MVC" Anti-Pattern)</h4>
                    <p><strong>Explanation:</strong> In this initial code, the <code>CounterView</code> is doing too much. It holds the <code>Counter</code> model directly and contains the logic (<code>counter.value += 1</code>) inside the button's action. For a simple app, this might seem fine, but as apps grow, this approach becomes messy, hard to test, and difficult to debug. Imagine if this view also had to handle user profiles and settings‚Äîit would become a tangled mess!</p>
                    <p><strong>Model (Data structure):</strong></p>
                    <pre><code><span class="keyword">struct</span> <span class="type">Counter</span> {
    <span class="keyword">var</span> value: <span class="type">Int</span>
}</code></pre>
                    <p><strong>View (User Interface with embedded logic):</strong></p>
                    <pre><code><span class="keyword">import</span> <span class="type">SwiftUI</span>
<span class="keyword">struct</span> <span class="type">CounterView</span>: <span class="type">View</span> {
    <span class="property-wrapper">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> counter = <span class="function">Counter</span>(value: <span class="number">0</span>) <span class="comment">// View owns the model state</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="function">VStack</span>(spacing: <span class="number">20</span>) {
            <span class="function">Text</span>(<span class="string">"Count: \(counter.value)"</span>)
                .<span class="function">font</span>(.<span class="variable">largeTitle</span>)
            <span class="function">Button</span>(<span class="string">"Increment"</span>) {
                counter.value += <span class="number">1</span> <span class="comment">// Business logic is inside the view</span>
            }
        }
        .<span class="function">padding</span>()
    }
}</code></pre>
                    
                    <h4>2. Refactoring to MVVM</h4>
                    <p><strong>a. Model (Unchanged):</strong></p>
                    <p><strong>Explanation:</strong> The Model's role is purely to define the data structure. It should not contain any business logic. In this case, it's perfect as is.</p>
                    <pre><code><span class="keyword">struct</span> <span class="type">Counter</span> {
    <span class="keyword">var</span> value: <span class="type">Int</span>
}</code></pre>

                    <p><strong>b. ViewModel (The Brains):</strong></p>
                    <p><strong>Explanation:</strong> The ViewModel acts as the bridge. It conforms to <code>ObservableObject</code> so that SwiftUI views can subscribe to its changes. The <code>@Published</code> property wrapper automatically announces any changes to the <code>counter</code> property, causing any observing views to re-render. The <code>increment()</code> function contains the business logic, neatly separated from the UI.</p>
                    <pre><code><span class="keyword">import</span> <span class="type">Foundation</span>
<span class="keyword">class</span> <span class="type">CounterViewModel</span>: <span class="type">ObservableObject</span> {
    <span class="property-wrapper">@Published</span> <span class="keyword">var</span> counter = <span class="function">Counter</span>(value: <span class="number">0</span>)
    
    <span class="comment">// Business Logic</span>
    <span class="keyword">func</span> <span class="function">increment</span>() {
        counter.value += <span class="number">1</span>
    }
}</code></pre>

                    <p><strong>c. View (The UI Layer):</strong></p>
                    <p><strong>Explanation:</strong> The View is now much "dumber." Its only job is to display the data from the ViewModel and send user actions (like button taps) to the ViewModel. We use <code>@StateObject</code> because this <code>CounterView</code> is the first view to use the <code>CounterViewModel</code> and should be responsible for creating and owning it.</p>
                    <pre><code><span class="keyword">import</span> <span class="type">SwiftUI</span>
<span class="keyword">struct</span> <span class="type">CounterView</span>: <span class="type">View</span> {
    <span class="property-wrapper">@StateObject</span> <span class="keyword">var</span> viewModel = <span class="function">CounterViewModel</span>()
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="function">VStack</span>(spacing: <span class="number">20</span>) {
            <span class="function">Text</span>(<span class="string">"Count: \(viewModel.counter.value)"</span>) <span class="comment">// Reads from ViewModel</span>
                .<span class="function">font</span>(.<span class="variable">largeTitle</span>)
            <span class="function">Button</span>(<span class="string">"Increment"</span>) {
                viewModel.<span class="function">increment</span>() <span class="comment">// Sends action to ViewModel</span>
            }
        }
        .<span class="function">padding</span>()
    }
}</code></pre>

                    <h4>Your Task: Extend the Functionality</h4>
                    <p>Now, apply what you've learned to extend the app:</p>
                    <ul>
                        <li><strong>Add more logic to the ViewModel:</strong> Open <code>CounterViewModel.swift</code> and add two new functions: <code>decrement()</code> and <code>reset()</code>.</li>
                        <li><strong>Update the View:</strong> In <code>CounterView.swift</code>, add two new buttons for "Decrement" and "Reset". Connect them to the new functions in your ViewModel. Consider using an <code>HStack</code> to arrange the buttons neatly.</li>
                        <li><strong>(Optional) Add Animation:</strong> In <code>CounterView</code>, try adding the <code>.animation(.default, value: viewModel.counter.value)</code> modifier to the <code>Text</code> view to see how easily SwiftUI can animate state changes.</li>
                    </ul>

                    <div class="pro-tip">
                        <h4>Pro Tip: The Single Responsibility Principle</h4>
                        <p>This refactoring is a perfect example of the Single Responsibility Principle. The View's responsibility is to display UI. The ViewModel's responsibility is to handle presentation logic. The Model's responsibility is to hold data. By keeping these separate, our code becomes cleaner, more modular, and easier to manage.</p>
                    </div>

                    <h4>Questions for Reflection (with hints):</h4>
                    <ol>
                        <li><strong>Why is it beneficial to separate business logic from the view?</strong>
                            <br><em>Hint: Think about Testing (you can test the ViewModel without any UI), Reusability (could another view use the same ViewModel?), and Complexity (what happens when logic gets complicated?).</em></li>
                        <li><strong>How does the <code>@StateObject</code> property wrapper help with MVVM in SwiftUI?</strong>
                            <br><em>Hint: It ensures the ViewModel's lifecycle is tied to the view's lifecycle, preventing it from being accidentally destroyed and recreated during view updates.</em></li>
                        <li><strong>How does MVVM affect the reusability and maintainability of our code?</strong>
                            <br><em>Hint: With clear separation, you can change the UI (View) without touching the business logic (ViewModel), and vice-versa. This makes updates and bug fixes much safer and easier.</em></li>
                    </ol>
                </div>
            </div>
        </section>
        
        <section class="cheatsheet-section" id="task2">
            <h2 class="collapsible-header">
                ‚úÖ Task 2: Designing a To-Do List App with MVVM
                <span class="collapse-icon"></span>
            </h2>
            <div class="collapsible-content">
                <div class="card instruction-step">
                    <h3>Objective</h3>
                    <p>Build a slightly more complex app from scratch using the MVVM pattern. This will solidify your understanding of how the components work together to manage a list of data.</p>
                    
                    <h4>Getting Started</h4>
                    <p>Create a new SwiftUI project in Xcode named "MVVMToDoList".</p>
                    
                    <h4>1. Design the Model</h4>
                    <p><strong>Explanation:</strong> This is our data blueprint. Each <code>Task</code> has a unique ID (essential for lists in SwiftUI), a title, an optional description, and a completion status. Conforming to <code>Codable</code> is for the optional persistence challenge, and <code>Identifiable</code> is for SwiftUI to track items in a list.</p>
                    <pre><code><span class="keyword">import</span> <span class="type">Foundation</span>
<span class="keyword">struct</span> <span class="type">Task</span>: <span class="type">Codable</span>, <span class="type">Identifiable</span> {
    <span class="keyword">var</span> id: <span class="type">UUID</span> = <span class="function">UUID</span>()
    <span class="keyword">var</span> title: <span class="type">String</span>
    <span class="keyword">var</span> description: <span class="type">String</span>?
    <span class="keyword">var</span> isDone: <span class="type">Bool</span> = <span class="literal">false</span>
}</code></pre>
                    
                    <h4>2. Implementing the ViewModel</h4>
                    <p><strong>Explanation:</strong> The <code>TaskListViewModel</code> manages the array of tasks. It exposes the <code>tasks</code> array as a <code>@Published</code> property and provides functions (<code>addTask</code>, <code>deleteTask</code>, <code>toggleTaskDone</code>) that act as a clean API for the View to interact with the data. The View never modifies the <code>tasks</code> array directly.</p>
                    <pre><code><span class="keyword">import</span> <span class="type">Foundation</span>
<span class="keyword">class</span> <span class="type">TaskListViewModel</span>: <span class="type">ObservableObject</span> {
    <span class="property-wrapper">@Published</span> <span class="keyword">var</span> tasks: [<span class="type">Task</span>] = []
    
    <span class="keyword">func</span> <span class="function">addTask</span>(title: <span class="type">String</span>, description: <span class="type">String</span>?) {
        <span class="keyword">let</span> task = <span class="function">Task</span>(title: title, description: description)
        tasks.<span class="function">append</span>(task)
    }
    
    <span class="keyword">func</span> <span class="function">deleteTask</span>(at offsets: <span class="type">IndexSet</span>) {
        tasks.<span class="function">remove</span>(atOffsets: offsets)
    }
    
    <span class="keyword">func</span> <span class="function">toggleTaskDone</span>(at index: <span class="type">Int</span>) {
        tasks[index].isDone.<span class="function">toggle</span>()
    }
}</code></pre>
                    
                    <h4>3. Designing the View</h4>
                    <p><strong>TaskRowView (Child View):</strong></p>
                    <p><strong>Explanation:</strong> This view is responsible for displaying a single task. It uses <code>@Binding</code> because it needs to reflect changes made in the parent (like toggling the <code>isDone</code> status) and potentially allow for edits in the future.</p>
                    <pre><code><span class="keyword">import</span> <span class="type">SwiftUI</span>
<span class="keyword">struct</span> <span class="type">TaskRowView</span>: <span class="type">View</span> {
    <span class="property-wrapper">@Binding</span> <span class="keyword">var</span> task: <span class="type">Task</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="function">HStack</span> {
            <span class="function">VStack</span>(alignment: .leading) {
                <span class="function">Text</span>(task.title)
                    .<span class="function">font</span>(.<span class="variable">headline</span>)
                <span class="keyword">if</span> <span class="keyword">let</span> description = task.description, !description.<span class="property">isEmpty</span> {
                    <span class="function">Text</span>(description)
                        .<span class="function">font</span>(.<span class="variable">subheadline</span>)
                }
            }
            <span class="function">Spacer</span>()
            <span class="keyword">if</span> task.isDone {
                <span class="function">Image</span>(systemName: <span class="string">"checkmark.circle.fill"</span>)
                    .<span class="function">foregroundColor</span>(.<span class="variable">green</span>)
            }
        }
        .<span class="function">padding</span>()
    }
}
<span class="comment">#Preview</span> {
    <span class="function">TaskRowView</span>(task: .<span class="function">constant</span>(<span class="function">Task</span>(title: <span class="string">"Sample Task"</span>, description: <span class="string">"This is a description."</span>, isDone: <span class="literal">false</span>)))
}</code></pre>

                    <p><strong>TaskListView (Parent View):</strong></p>
                    <p><strong>Explanation:</strong> This view owns the <code>TaskListViewModel</code> using <code>@StateObject</code>. It iterates over the tasks from the ViewModel to create the list. All user actions, like adding, deleting, or toggling a task, are forwarded to the ViewModel to handle.</p>
                    <pre><code><span class="keyword">import</span> <span class="type">SwiftUI</span>
<span class="keyword">struct</span> <span class="type">TaskListView</span>: <span class="type">View</span> {
    <span class="property-wrapper">@StateObject</span> <span class="keyword">var</span> viewModel: <span class="type">TaskListViewModel</span> = <span class="function">TaskListViewModel</span>()
    <span class="property-wrapper">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> newTaskTitle: <span class="type">String</span> = <span class="string">""</span>
    <span class="property-wrapper">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> newTaskDescription: <span class="type">String</span> = <span class="string">""</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="function">NavigationView</span> {
            <span class="function">List</span> {
                <span class="function">ForEach</span>(viewModel.tasks.indices, id: \.<span class="keyword">self</span>) { index <span class="keyword">in</span>
                    <span class="function">Button</span>(action: {
                        viewModel.<span class="function">toggleTaskDone</span>(at: index)
                    }) {
                        <span class="function">TaskRowView</span>(task: $viewModel.tasks[index])
                    }
                }
                .<span class="function">onDelete</span>(perform: viewModel.deleteTask)
                <span class="function">HStack</span> {
                    <span class="function">TextField</span>(<span class="string">"New task title"</span>, text: $<span class="variable">newTaskTitle</span>)
                    <span class="function">TextField</span>(<span class="string">"Description (optional)"</span>, text: $<span class="variable">newTaskDescription</span>)
                    <span class="function">Button</span>(<span class="string">"Add"</span>) {
                        viewModel.<span class="function">addTask</span>(title: newTaskTitle, description: newTaskDescription)
                        newTaskTitle = <span class="string">""</span>
                        newTaskDescription = <span class="string">""</span>
                    }
                }
            }
            .<span class="function">navigationBarTitle</span>(<span class="string">"Tasks"</span>)
            .<span class="function">navigationBarItems</span>(trailing: <span class="function">EditButton</span>())
        }
    }
}
<span class="comment">#Preview</span> {
    <span class="function">TaskListView</span>()
}</code></pre>

                    <h4>4. Additional Exercises (Optional)</h4>
                    <ol>
                        <li><strong>Styling:</strong> Experiment with different <code>ListStyle</code>s, add custom fonts, or change the color of the checkmark.</li>
                        <li><strong>Validation:</strong> In the "Add" button's action within <code>TaskListView</code>, add a simple check: <code>if !newTaskTitle.isEmpty { ... }</code>. You could also disable the button if the title is empty.</li>
                        <li><strong>Persistence:</strong> Follow the hints in the lab PDF to make your <code>Task</code> model <code>Codable</code> and add <code>saveTasks()</code> and <code>loadTasks()</code> methods to your ViewModel. Call these methods whenever the task list is modified.</li>
                    </ol>
                    
                    <h4 class="collapsible-header" style="background-color: var(--accent-color-light); color: var(--accent-color); padding: 10px; border-radius: 5px; margin-top: 20px;">
                        ‚ñ∂Ô∏è Click to view hints for the persistence task (if you get stuck)
                        <span class="collapse-icon"></span>
                    </h4>
                    <div class="collapsible-content">
                        <p><strong>Task</strong> - Make the <code>Task</code> struct to be <code>Codable</code>. The <code>Task</code> struct needs to be <code>Codable</code> because it allows for easy encoding to and decoding from a format that can be stored in UserDefaults:</p>
                        <pre><code><span class="keyword">import</span> <span class="type">Foundation</span>
<span class="keyword">struct</span> <span class="type">Task</span>: <span class="type">Codable</span> {
    <span class="keyword">var</span> id: <span class="type">UUID</span> = <span class="function">UUID</span>()
    <span class="keyword">var</span> title: <span class="type">String</span>
    <span class="keyword">var</span> description: <span class="type">String</span>?
    <span class="keyword">var</span> isDone: <span class="type">Bool</span> = <span class="literal">false</span>
}</code></pre>
                        <p>Let's make the ViewModel that will save the tasks using <code>userDefaults</code> after every operation related to tasks. The <code>Task</code> instances are being saved to <code>UserDefaults</code> as <code>Data</code> and later retrieved from it.:</p>
                        <pre><code><span class="keyword">import</span> <span class="type">Foundation</span>
<span class="keyword">class</span> <span class="type">TaskListViewModel</span>: <span class="type">ObservableObject</span> {
    <span class="property-wrapper">@Published</span> <span class="keyword">var</span> tasks: [<span class="type">Task</span>] = []
    <span class="keyword">private</span> <span class="keyword">let</span> userDefaultsKey = <span class="string">"taskList"</span>
    
    <span class="keyword">init</span>() {
        <span class="function">loadTasks</span>()
    }
    <span class="keyword">func</span> <span class="function">addTask</span>(title: <span class="type">String</span>, description: <span class="type">String</span>?) {
        <span class="keyword">let</span> task = <span class="function">Task</span>(title: title, description: description)
        tasks.<span class="function">append</span>(task)
        <span class="function">saveTasks</span>()
    }
    <span class="keyword">func</span> <span class="function">deleteTask</span>(at offsets: <span class="type">IndexSet</span>) {
        tasks.<span class="function">remove</span>(atOffsets: offsets)
        <span class="function">saveTasks</span>()
    }
    <span class="keyword">func</span> <span class="function">toggleTaskDone</span>(at index: <span class="type">Int</span>) {
        tasks[index].isDone.<span class="function">toggle</span>()
        <span class="function">saveTasks</span>()
    }
    
    <span class="keyword">private</span> <span class="keyword">func</span> <span class="function">saveTasks</span>() {
        <span class="keyword">if</span> <span class="keyword">let</span> encodedData = <span class="keyword">try</span>? <span class="function">JSONEncoder</span>().<span class="function">encode</span>(tasks) {
            <span class="type">UserDefaults</span>.<span class="variable">standard</span>.<span class="function">set</span>(encodedData, forKey: userDefaultsKey)
        }
    }
    
    <span class="keyword">private</span> <span class="keyword">func</span> <span class="function">loadTasks</span>() {
        <span class="keyword">if</span> <span class="keyword">let</span> savedData = <span class="type">UserDefaults</span>.<span class="variable">standard</span>.<span class="function">data</span>(forKey: userDefaultsKey),
           <span class="keyword">let</span> decodedData = <span class="keyword">try</span>? <span class="function">JSONDecoder</span>().<span class="function">decode</span>([<span class="type">Task</span>].<span class="keyword">self</span>, from: savedData) {
            tasks = decodedData
        }
    }
}</code></pre>
                        <p>Here's a breakdown:</p>
                        <ul>
                            <li><strong>Encoding (Serialization):</strong> When you want to save tasks, you convert (encode) the array of tasks (<code>[Task]</code>) into <code>Data</code> using <code>JSONEncoder().encode(tasks)</code>. This requires the <code>Task</code> struct to conform to the <code>Encodable</code> protocol.</li>
                            <li><strong>Decoding (Deserialization):</strong> When you want to load tasks from <code>UserDefaults</code>, you retrieve the stored <code>Data</code> and convert (decode) it back to an array of <code>Task</code> instances using <code>JSONDecoder().decode([Task].self, from: savedData)</code>. This requires the <code>Task</code> struct to conform to the <code>Decodable</code> protocol.</li>
                        </ul>
                        <p>Now, you can try to create some tasks and toggle ‚Äúdone‚Äù for some tasks. After that, you try to close the app and open it again. Hopefully, all of the tasks are still there as they are saved and loaded from the <code>userDefaults</code>.</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="cheatsheet-section" id="task3">
            <h2 class="collapsible-header">
                üå≥ Task 3: Integrating @EnvironmentObject
                <span class="collapse-icon"></span>
            </h2>
            <div class="collapsible-content">
                <div class="card instruction-step">
                    <h3>Objective</h3>
                    <p>Modify your existing MVVM and SwiftUI To-Do list app to use @EnvironmentObject instead of @StateObject to manage the state and actions of your tasks.</p>
                    <h4>1. Create the ViewModel at the Top Level</h4>
                    <p>In your main App file (<code>MVVMToDoListApp.swift</code>), you will create an instance of <code>TaskListViewModel</code>. This instance will be used globally in your SwiftUI application. Here's how you can do it:</p>
                    <pre><code><span class="property-wrapper">@main</span>
<span class="keyword">struct</span> <span class="type">MVVMToDoListApp</span>: <span class="type">App</span> {
    <span class="property-wrapper">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> viewModel = <span class="function">TaskListViewModel</span>()
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> {
        <span class="function">WindowGroup</span> {
            <span class="function">TaskListView</span>()
                .<span class="function">environmentObject</span>(viewModel)
        }
    }
}</code></pre>
                    <p>In the above code:</p>
                    <ul>
                        <li>We declared an instance of <code>TaskListViewModel</code> with <code>@StateObject</code>, which signifies that this instance will own the object and manage its life cycle.</li>
                        <li>We then used <code>.environmentObject(viewModel)</code> to inject the view model into the environment so that it can be accessed by views in the view hierarchy.</li>
                    </ul>
                    <h4>2. Accessing the ViewModel in TaskListView</h4>
                    <p>Now, inside your <code>TaskListView</code>, instead of creating a new instance of <code>TaskListViewModel</code>, you will declare a property to hold the environment object like so:</p>
                    <pre><code><span class="keyword">struct</span> <span class="type">TaskListView</span>: <span class="type">View</span> {
    <span class="property-wrapper">@EnvironmentObject</span> <span class="keyword">var</span> viewModel: <span class="type">TaskListViewModel</span>
    
    <span class="property-wrapper">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> newTaskTitle: <span class="type">String</span> = <span class="string">""</span>
    <span class="property-wrapper">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> newTaskDescription: <span class="type">String</span> = <span class="string">""</span>
    
    <span class="comment">// ... (rest of the code remains the same)</span>
}</code></pre>
                    <p>The <code>@EnvironmentObject</code> property wrapper will look up the environment for an object of the specified type (<code>TaskListViewModel</code> in this case) and get a reference to it. Now your view has a reference to the <code>viewModel</code> that is shared across the entire app.</p>
                    <h4>3. Test Your Changes</h4>
                    <p>Once you have made the changes, test your application thoroughly to make sure that the ViewModel is working correctly as an environment object.</p>
                    <ol>
                        <li>Add, delete, and toggle tasks to confirm the correct working of the ViewModel.</li>
                        <li>Try accessing the ViewModel in a new view to confirm that the environment object is being passed down correctly.</li>
                    </ol>
                    <p>Remember, any views that access the environment object must be within the view hierarchy where the object was injected. If not, the app will crash at runtime. For example, in our case, the <code>TaskListView</code> preview will crash due to missing the environment object of <code>TaskListViewModel</code>. In order to fix this, you need to pass in a <code>TaskListViewModel</code> object to this view just like how you create <code>TaskListViewModel()</code> object and pass it in <code>TaskListView</code> using <code>.environmentObject()</code>. In short, in the preview you just need to do this:</p>
                    <pre><code><span class="comment">#Preview</span> {
    <span class="function">TaskListView</span>()
        .<span class="function">environmentObject</span>(<span class="function">TaskListViewModel</span>())
}</code></pre>
                    <p>In the above snippet:</p>
                    <ul>
                        <li>We've modified the <code>TaskListView_Previews</code> to include a <code>.environmentObject</code> modifier with a new instance of <code>TaskListViewModel</code>. This will inject a view model instance into the environment for the preview to use, hence preventing the crash.</li>
                        <li>We create a new instance of <code>TaskListViewModel</code> and supply it to the <code>.environmentObject</code> modifier. This is crucial as it allows the preview to have access to a <code>TaskListViewModel</code> instance, which it requires to function correctly.</li>
                    </ul>
                    <p>After making this change, your preview should work correctly, and you will be able to see your <code>TaskListView</code> preview without any crashes. Remember to do similar changes wherever previews for views that depend on the environment object are defined.</p>
                    <div class="pro-tip">
                        <h4>Note:</h4>
                        <p>By following these instructions, you will successfully migrate your project from using <code>@StateObject</code> to <code>@EnvironmentObject</code>, making it easier to manage shared data between different views in your SwiftUI application.</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="cheatsheet-section" id="task4">
            <h2 class="collapsible-header">
                üöÄ Task 4: The New Observation Framework
                <span class="collapse-icon"></span>
            </h2>
            <div class="collapsible-content">
                <div class="card instruction-step">
                    <h3>Objective</h3>
                    <p>Adapt your project to use the modern, simpler, and more performant Observation framework introduced in iOS 17. This isn't just a syntax update; it's a fundamental improvement to data flow in SwiftUI.</p>
                    
                    <h4>1. The ViewModel: From <code>ObservableObject</code> to <code>@Observable</code></h4>
                    <p>The core of the new framework is the <code>@Observable</code> macro. It replaces the <code>ObservableObject</code> protocol and the <code>@Published</code> property wrapper, dramatically simplifying your code.</p>
                    <p><strong>Before (The Old Way):</strong></p>
                    <pre><code><span class="keyword">import</span> <span class="type">Combine</span> <span class="comment">// Required for ObservableObject</span>
<span class="keyword">class</span> <span class="type">TaskListViewModel</span>: <span class="type">ObservableObject</span> {
    <span class="property-wrapper">@Published</span> <span class="keyword">var</span> tasks: [<span class="type">Task</span>] = []
    <span class="property-wrapper">@Published</span> <span class="keyword">var</span> filterText: <span class="type">String</span> = <span class="string">""</span>
}</code></pre>
                    <p><strong>After (The Modern Way):</strong></p>
                    <pre><code><span class="keyword">import</span> <span class="type">Observation</span> <span class="comment">// Don't forget to import!</span>

<span class="property-wrapper">@Observable</span>
<span class="keyword">class</span> <span class="type">TaskListViewModel</span> {
    <span class="keyword">var</span> tasks: [<span class="type">Task</span>] = []
    <span class="keyword">var</span> filterText: <span class="type">String</span> = <span class="string">""</span>
    <span class="comment">// All business logic (addTask, deleteTask, etc.) remains the same.</span>
}</code></pre>
                    <div class="pro-tip">
                        <h4>What's Happening Under the Hood?</h4>
                        <p>The <code>@Observable</code> macro rewrites your class at compile time to add observation support to every property automatically. You no longer need to manually mark which properties should trigger UI updates. This reduces boilerplate and eliminates a common source of bugs.</p>
                    </div>

                    <h4>2. The View: Simplifying State Ownership</h4>
                    <p>When a view "owns" a ViewModel (i.e., it creates the instance), the property wrapper changes from <code>@StateObject</code> to the familiar <code>@State</code>. SwiftUI recognizes that the class is <code>@Observable</code> and automatically manages its lifecycle correctly, preventing it from being destroyed during view updates.</p>
                    <p><strong>Before (`@StateObject`):</strong></p>
                    <pre><code><span class="keyword">struct</span> <span class="type">TaskListView</span>: <span class="type">View</span> {
    <span class="property-wrapper">@StateObject</span> <span class="keyword">var</span> viewModel = <span class="function">TaskListViewModel</span>()
    <span class="comment">// ... view body ...</span>
}</code></pre>
                    <p><strong>After (`@State`):</strong></p>
                    <pre><code><span class="keyword">struct</span> <span class="type">TaskListView</span>: <span class="type">View</span> {
    <span class="property-wrapper">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> viewModel = <span class="function">TaskListViewModel</span>()
    <span class="comment">// ... view body ...</span>
}</code></pre>

                    <h4>3. Shared State: A Clearer Approach with <code>@Environment</code> and <code>@Bindable</code></h4>
                    <p>For state shared across many views, the syntax for injecting, accessing, and binding is also modernized.</p>
                    
                    <p><strong>a. Injecting the Object (in your App file and Preview):</strong></p>
                    <p>The <code>.environmentObject()</code> modifier is replaced by the simpler <code>.environment()</code> modifier.</p>
                    <p><strong>Before:</strong> <code>.environmentObject(viewModel)</code><br>
                       <strong>After:</strong> <code>.environment(viewModel)</code></p>

                    <p><strong>b. Accessing and Binding in the View:</strong></p>
                    <p>This is where the new pattern shines. You now use a two-step process that makes your code's intent much clearer:</p>
                    <ol>
                        <li>Access the read-only object from the environment with <code>@Environment</code>.</li>
                        <li>If you need to create two-way bindings (for a <code>TextField</code>, <code>Toggle</code>, etc.), create a temporary, bindable version inside the `body` using the <code>@Bindable</code> property wrapper.</li>
                    </ol>
                    
                    <p><strong>Example Implementation:</strong></p>
                    <pre><code><span class="keyword">struct</span> <span class="type">TaskListView</span>: <span class="type">View</span> {
    <span class="comment">// 1. Access the shared ViewModel from the environment.</span>
    <span class="property-wrapper">@Environment</span>(<span class="type">TaskListViewModel</span>.<span class="keyword">self</span>) <span class="keyword">var</span> viewModel
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="comment">// 2. Create a bindable wrapper ONLY for views that need it.</span>
        <span class="property-wrapper">@Bindable</span> <span class="keyword">var</span> viewModel = viewModel
        
        <span class="function">NavigationView</span> {
            <span class="function">VStack</span> {
                <span class="comment">// Use the binding for a TextField</span>
                <span class="function">TextField</span>(<span class="string">"Filter tasks..."</span>, text: $viewModel.filterText)
                    .<span class="function">padding</span>()

                <span class="function">List</span> {
                    <span class="comment">// Use the binding to get bindings to elements in a collection</span>
                    <span class="function">ForEach</span>($viewModel.tasks) { $task <span class="keyword">in</span>
                        <span class="function">TaskRowView</span>(task: $task)
                    }
                }
            }
        }
    }
}</code></pre>
                    
                    <div class="pro-tip">
                        <h4>Why the <code>@Bindable</code> Wrapper?</h4>
                        <p>This explicit step is a powerful design choice. It clearly separates "reading" data from "writing" data. A view that only displays information doesn't need the <code>@Bindable</code> wrapper, making the code safer and easier to reason about. It signals to other developers (and to SwiftUI) that this specific part of the view is intended to modify the state.</p>
                    </div>

                    <h4>The Biggest Win: Performance</h4>
                    <p>The most significant advantage of the Observation framework is its performance. It is far more efficient than the old <code>ObservableObject</code> system.</p>
                    <ul>
                        <li><strong>Old Way (<code>ObservableObject</code>):</strong> When *any* <code>@Published</code> property changed, the entire object would send a notification. Every view observing that object would then have to re-evaluate its `body`, even if it didn't use the property that changed.</li>
                        <li><strong>New Way (<code>@Observable</code>):</strong> SwiftUI now tracks dependencies at the property level. It knows exactly which view uses which property. A view will only be re-evaluated if a property it is *actually using* changes.</li>
                    </ul>
                    <div class="pro-tip">
                        <h4>An Analogy: Smart vs. Inefficient Notifications</h4>
                        <p>Imagine you're subscribed to a news service. <code>ObservableObject</code> is like getting a notification for *every single article* published, forcing you to check if it's relevant. <code>@Observable</code> is like a smart subscription where you only get notified about the specific topics you care about. It's less work for you and for the system.</p>
                    </div>

                    <h4>Key Changes Summarized</h4>
                    <table class="summary-table">
                        <thead>
                            <tr>
                                <th>Concept</th>
                                <th>Old Way (Combine/SwiftUI)</th>
                                <th>New Way (Observation)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Model Definition</strong></td>
                                <td><code>class C: ObservableObject { @Published var p }</code></td>
                                <td><code>@Observable class C { var p }</code></td>
                            </tr>
                            <tr>
                                <td><strong>Owning a Model</strong></td>
                                <td><code>@StateObject var vm = ViewModel()</code></td>
                                <td><code>@State private var vm = ViewModel()</code></td>
                            </tr>
                            <tr>
                                <td><strong>Sharing a Model</strong></td>
                                <td><code>.environmentObject(vm)</code></td>
                                <td><code>.environment(vm)</code></td>
                            </tr>
                            <tr>
                                <td><strong>Accessing Shared Model</strong></td>
                                <td><code>@EnvironmentObject var vm: ViewModel</code></td>
                                <td><code>@Environment(ViewModel.self) var vm</code></td>
                            </tr>
                            <tr>
                                <td><strong>Creating Bindings</strong></td>
                                <td><code>$vm.property</code></td>
                                <td><code>@Bindable var vm = vm; $vm.property</code></td>
                            </tr>
                        </tbody>
                    </table>

                    <p>Your task is to refactor your To-Do list app to use this new framework. The logic inside your ViewModel should not need to change at all!</p>
                    <img src="../assets/guide_imgs/mvmm/new-observation-framework-task.png" alt="Illustration of the new Observation Framework" class="img-large">
                </div>
            </div>
        </section>

        <section class="cheatsheet-section" id="challenge">
            <h2 class="collapsible-header">
                üèÜ Challenge: OpenWeatherMap Weather App
                <span class="collapse-icon"></span>
            </h2>
            <div class="collapsible-content">
                <div class="card instruction-step">
                    <h3>Objective</h3>
                    <p>Combine everything you've learned‚ÄîMVVM, data flow, and asynchronous networking‚Äîto build a real-world app that fetches data from an online API.</p>
                    <img src="../assets/guide_imgs/mvmm/weather-app-objective-illustration.png" alt="Weather app objective illustration showing MVVM architecture with API integration" class="img-large">
                    
                    <h4>Setting Up OpenWeather API</h4>
                    <p>Before building the app, you need to set up access to the OpenWeather API:</p>
                    <ol>
                        <li><strong>Sign up for OpenWeather account:</strong> Please sign up for the account with OpenWeather to generate the free API key to request the weather information from their server. Visit: <a href="https://home.openweathermap.org/users/sign_up" target="_blank">https://home.openweathermap.org/users/sign_up</a>
                            <br><img src="../assets/guide_imgs/mvmm/openweather-signup-step.png" alt="OpenWeather signup page illustration" class="img-large"></li>
                        <li><strong>Copy your API key:</strong> After creating your account, copy the API key that you just created from your dashboard.
                            <br><img src="../assets/guide_imgs/mvmm/openweather-api-key-copy-step.png" alt="OpenWeather API key copy step illustration" class="img-large"></li>
                        <li><strong>Explore the API documentation:</strong> Open the OpenWeather API page: <a href="https://openweathermap.org/api" target="_blank">https://openweathermap.org/api</a>. Browse through to understand their available weather data we can get from their API.
                            <br><img src="../assets/guide_imgs/mvmm/openweather-api-documentation-page.png" alt="OpenWeather API documentation page illustration" class="img-large"></li>
                        <li><strong>Focus on current weather data:</strong> However, we are interested in current weather data based on city name: <a href="https://openweathermap.org/current#name" target="_blank">https://openweathermap.org/current#name</a></li>
                    </ol>

                    <h4>Testing the API</h4>
                    <p>To test it out, you can follow this syntax URL:</p>
                    <pre><code><span class="string">https://api.openweathermap.org/data/2.5/weather?q=<CITY_NAME>&appid=<API_KEY></span></code></pre>
                    <p>For example, the city name is Ho Chi Minh and my API key is 757eca7ee79866f0fb009b8c9098f3ca (please maybe use your own API key :) )</p>
                    <p>So the request URL for Ho Chi Minh city will be:</p>
                    <pre><code><span class="string">https://api.openweathermap.org/data/2.5/weather?q=ho%20chi%20minh&appid=757eca7ee79866f0fb009b8c9098f3ca&units=metric</span></code></pre>
                    <p><strong>Sample JSON Response:</strong></p>
                    <pre><code>{<span class="string">"coord"</span>:{<span class="string">"lon"</span>:<span class="number">106.6667</span>,<span class="string">"lat"</span>:<span class="number">10.75</span>},<span class="string">"weather"</span>:[{<span class="string">"id"</span>:<span class="number">211</span>,<span class="string">"main"</span>:<span class="string">"Thunderstorm"</span>,<span class="string">"description"</span>:<span class="string">"thunderstorm"</span>,<span class="string">"icon"</span>:<span class="string">"11d"</span>}],<span class="string">"base"</span>:<span class="string">"stations"</span>,<span class="string">"main"</span>:{<span class="string">"temp"</span>:<span class="number">32.01</span>,<span class="string">"feels_like"</span>:<span class="number">37.72</span>,<span class="string">"temp_min"</span>:<span class="number">32.01</span>,<span class="string">"temp_max"</span>:<span class="number">32.01</span>,<span class="string">"pressure"</span>:<span class="number">1005</span>,<span class="string">"humidity"</span>:<span class="number">62</span>},<span class="string">"visibility"</span>:<span class="number">10000</span>,<span class="string">"wind"</span>:{<span class="string">"speed"</span>:<span class="number">4.63</span>,<span class="string">"deg"</span>:<span class="number">270</span>},<span class="string">"clouds"</span>:{<span class="string">"all"</span>:<span class="number">20</span>},<span class="string">"dt"</span>:<span class="number">1661248277</span>,<span class="string">"sys"</span>:{<span class="string">"type"</span>:<span class="number">1</span>,<span class="string">"id"</span>:<span class="number">9314</span>,<span class="string">"country"</span>:<span class="string">"VN"</span>,<span class="string">"sunrise"</span>:<span class="number">1661208236</span>,<span class="string">"sunset"</span>:<span class="number">1661252919</span>},<span class="string">"timezone"</span>:<span class="number">25200</span>,<span class="string">"id"</span>:<span class="number">1566083</span>,<span class="string">"name"</span>:<span class="string">"Ho Chi Minh City"</span>,<span class="string">"cod"</span>:<span class="number">200</span>}</code></pre>

                    <h4>Weather Data Fields of Interest</h4>
                    <p>The weather information we are interested in are:</p>
                    <ul>
                        <li><strong>country</strong> (from sys.country)</li>
                        <li><strong>temp</strong> (from main.temp)</li>
                        <li><strong>humidity</strong> (from main.humidity)</li>
                        <li><strong>wind speed</strong> (from wind.speed)</li>
                        <li><strong>sunrise</strong> (from sys.sunrise)</li>
                        <li><strong>sunset</strong> (from sys.sunset)</li>
                    </ul>

                    <h4>Implementation Instructions</h4>
                    <ol>
                        <li>Use the Current Weather Data API to fetch weather information based on a city name. The API endpoint format is: <br><code>https://api.openweathermap.org/data/2.5/weather?q={CITY_NAME}&appid={API_KEY}&units=metric</code></li>
                        <li>Create a UI with a <code>TextField</code> for the city name and a button to trigger the API request.</li>
                        <li>Display the weather information you are interested in, such as country, temperature, humidity, wind speed, sunrise, and sunset.</li>
                        <li>Use SF Symbols to display weather information (e.g., <code>thermometer.sun.fill</code>, <code>humidity.fill</code>, <code>wind</code>, etc.).</li>
                    </ol>
                    <h4>Extra Help:</h4>
                    <ul>
                        <li><a href="https://developer.apple.com/documentation/swiftui/textfield" target="_blank">Apple Developer Documentation: TextField</a></li>
                        <li><a href="https://developer.apple.com/documentation/SwiftUI/State-and-Data-Flow" target="_blank">Apple Developer Documentation: State and Data Flow</a></li>
                    </ul>
                    <h4>Suggested Architecture</h4>
                    <ul>
                        <li><strong>Model:</strong> Create Swift <code>struct</code>s that match the JSON structure returned by the OpenWeatherMap API. Make them <code>Codable</code> so you can easily decode the JSON response. You'll likely need a main <code>WeatherData</code> struct that contains nested structs for <code>Main</code> (temp, humidity), <code>Wind</code>, etc.</li>
                        <li><strong>ViewModel:</strong>
                            <ul>
                                <li>It should have properties to hold the fetched weather data (e.g., <code>@Published var weatherData: WeatherData?</code>).</li>
                                <li>Create an <code>async</code> function to fetch the data (e.g., <code>func fetchWeather(for city: String) async</code>).</li>
                                <li>Inside this function, use <code>URLSession.shared.data(from: url)</code> to make the network request.</li>
                                <li>Use <code>JSONDecoder()</code> to decode the received data into your model structs.</li>
                                <li>Update your published properties on the main thread (e.g., <code>DispatchQueue.main.async { ... }</code>).</li>
                            </ul>
                        </li>
                        <li><strong>View:</strong>
                            <ul>
                                <li>Have a <code>TextField</code> bound to a <code>@State</code> variable for the city name.</li>
                                <li>A <code>Button</code> that calls the ViewModel's <code>fetchWeather</code> function.</li>
                                <li>Display the weather data from the ViewModel. Use <code>if let</code> or optional chaining (<code>?.</code>) to safely unwrap the data, as it will be <code>nil</code> before the first fetch.</li>
                            </ul>
                        </li>
                    </ul>
                    <img src="../assets/guide_imgs/mvmm/weather-app-challenge.png" alt="Weather App Challenge UI example" class="img-large">
                </div>
            </div>
        </section>

    </main>

    <footer>
        <p>¬© 2025 Created by Tom Huynh with love ‚ù§Ô∏è</p>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>
